Value protocol ([\w-]+)
Value type ([\w-]+)
Value Filldown network (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})
Value Filldown mask (\d{1,2})
Value distance (\d+)
Value metric (\d+)
Value nexthop_ip (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})
Value nexthop_if ([\w\./]+)
Value uptime ([\w:\.]+)
Value nexthop_vrf (\S+)
Value tag (\d+( \(\w+\))?)
Value segid (\d+)
Value tunnelid (0x[a-f\d]+)
Value encap (\w+)

Start
  # Match the network/Prefix Line
  ^\s*${network}\/${mask}, ubest/mbest:
  #
  # Match VXLAN Route Entry
  ^\s+\*+via ${nexthop_ip}(%${nexthop_vrf})?, \[${distance}/${metric}\], ${uptime}, ${protocol}, ${type}, tag ${tag}\s+segid: ${segid}\s+tunnelid: ${tunnelid}\s+encap: ${encap} -> Record
  #
  # Match routes with no type, but with a tag (e.g. statics out SVIs with a tag)
  ^\s+\*+via ${nexthop_ip}(%${nexthop_vrf})?, ${nexthop_if}, \[${distance}\/${metric}\], ${uptime}, ${protocol}, tag ${tag} -> Record
  #
  # Match standard dynamic route line (with or without tag)
  ^\s+\*+via ${nexthop_ip}(%${nexthop_vrf})?, ${nexthop_if}, \[${distance}/${metric}\], ${uptime}, ${protocol}, ${type}(, tag ${tag})? -> Record
  #
  # Match route without a type (e.g. direct, local)
  ^\s+\*+via ${nexthop_ip}(%${nexthop_vrf})?, ${nexthop_if}, \[${distance}\/${metric}\], ${uptime}, ${protocol} -> Record
  #
  # Match route without an outgoing interface (e.g. some statics) (with tag)
  ^\s+\*+via ${nexthop_ip}(%${nexthop_vrf})?, \[${distance}\/${metric}\], ${uptime}, ${protocol}, tag ${tag} -> Record
  #
  # Match route without an outgoing interface (e.g. some statics) (without tag)
  ^\s+\*+via ${nexthop_ip}(%${nexthop_vrf})?, \[${distance}\/${metric}\], ${uptime}, ${protocol} -> Record
  #
  # Match route without a nexthop IP, only nexthop interface (e.g. null routes)
  ^\s+\*+via ${nexthop_if}, \[${distance}\/${metric}\], ${uptime}, ${protocol} -> Record

EOF
